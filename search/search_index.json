{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"fastboop documentation","text":"<p>Welcome to the fastboop docs.</p> <p>fastboop is a non-mutating live-boot pipeline: it boots supported devices ephemerally without flashing or changing install state.</p> <p>Start here:</p> <ul> <li>New users: User docs overview</li> <li>First boot flow: Quick start</li> <li>Contributors: Developer docs overview</li> </ul>"},{"location":"dev/","title":"fastboop developer docs","text":"<p>This section collects contributor-facing architecture and implementation references.</p>"},{"location":"dev/#core-docs","title":"Core docs","text":"<ul> <li>Contributors Introduction</li> <li>Device Profiles</li> <li>Boot Profiles</li> <li>Stage0</li> <li>Stage0 distribution</li> </ul>"},{"location":"dev/#attic","title":"Attic","text":"<p>Historical docs kept for context. These may not reflect current direction.</p> <ul> <li>Device Profiles v0 spec (archived)</li> <li>Stage0 v0 spec (archived)</li> <li>Dioxus notes (legacy)</li> </ul>"},{"location":"dev/BOOT_PROFILES/","title":"Boot Profiles","text":"<p>Think of Stage0 as the cursed initrd and Boot Profiles as the cursed config blob for it.</p> <p>Boot Profiles describe where boot artifacts come from and how stage0 should be adjusted per image/device. Use them when a plain rootfs path/URL is not enough.</p>"},{"location":"dev/BOOT_PROFILES/#source-of-truth","title":"Source of Truth","text":"<ul> <li>Schema types: <code>crates/fastboop-schema/src/lib.rs</code></li> <li>Codec + validation: <code>crates/fastboop-core/src/bootprofile.rs</code></li> <li>Artifact pipeline schema/codec: <code>gibblox-pipeline</code></li> <li>CLI tooling: <code>cli/src/commands/bootprofile.rs</code></li> </ul>"},{"location":"dev/BOOT_PROFILES/#two-representations","title":"Two Representations","text":"<ul> <li>Manifest (<code>BootProfileManifest</code>): YAML/JSON authoring format.</li> <li>Compiled (<code>BootProfile</code>): binary format used by runtime commands.</li> </ul> <p><code>fastboop boot</code> and <code>fastboop stage0</code> accept a compiled Boot Profile as the <code>ROOTFS</code> input.</p>"},{"location":"dev/BOOT_PROFILES/#minimal-manifest","title":"Minimal Manifest","text":"<pre><code>id: local-erofs\ndisplay_name: Local EROFS image\n\nrootfs:\n  erofs:\n    file: ./artifacts/rootfs.ero\n\nstage0:\n  extra_modules:\n    - ff-memless\n</code></pre>"},{"location":"dev/BOOT_PROFILES/#maximal-manifest-pipeline-heavy","title":"Maximal Manifest (Pipeline-Heavy)","text":"<pre><code>id: generic-edge-phone\ndisplay_name: Generic edge image\n\nrootfs:\n  ext4:\n    mbr:\n      index: 1\n      android_sparseimg:\n        xz:\n          http: https://downloads.example.com/images/generic-edge.img.xz\n\nkernel:\n  path: /vmlinuz\n  fat:\n    mbr:\n      index: 0\n      android_sparseimg:\n        xz:\n          http: https://downloads.example.com/images/generic-edge.img.xz\n\ndtbs:\n  path: /dtbs\n  fat:\n    mbr:\n      index: 0\n      android_sparseimg:\n        xz:\n          http: https://downloads.example.com/images/generic-edge.img.xz\n\nextra_cmdline: console=ttyMSM0,115200n8\n</code></pre>"},{"location":"dev/BOOT_PROFILES/#validation-highlights","title":"Validation Highlights","text":"<ul> <li><code>rootfs</code> schema supports <code>erofs</code>, <code>ext4</code>, and <code>fat</code>.</li> <li>Stage0 lower-root currently accepts <code>erofs</code> and <code>ext4</code>; use <code>fat</code> for kernel/dtbs source pipelines.</li> <li>Artifact pipeline validation/limits come from <code>gibblox-pipeline</code> (<code>MAX_PIPELINE_DEPTH=16</code>).</li> <li>GPT/MBR selector steps must choose exactly one selector field.</li> <li><code>kernel.path</code> and <code>dtbs.path</code> (if present) must be non-empty.</li> <li><code>dt_overlays</code> compile/decompile requires <code>dtc</code>.</li> </ul>"},{"location":"dev/BOOT_PROFILES/#how-to-bang-on-it","title":"How To Bang On It","text":"<pre><code># compile manifest -&gt; binary\ncargo run -p fastboop-cli -- bootprofile create ./profile.yaml -o /tmp/profile.fbp\n\n# inspect binary -&gt; yaml\ncargo run -p fastboop-cli -- bootprofile show /tmp/profile.fbp\n\n# exercise stage0 path through compiled profile\ncargo run -p fastboop-cli -- stage0 /tmp/profile.fbp --device-profile &lt;id&gt; &gt; /tmp/stage0.cpio\n</code></pre>"},{"location":"dev/CONTRIBUTORS_INTRODUCTION/","title":"Contributors Introduction","text":"<p>fastboop is a non-mutating live-boot pipeline for fastboot-class devices.</p> <p>If this stack feels alien at first, keep this map in your head:</p> <ul> <li>Device Profile (DevPro): \"what is this device and how can it boot safely?\"</li> <li>Boot Profile: \"where do artifacts come from and what stage0 tweaks are needed?\"</li> <li>Stage0: tiny PID1 initrd that launches smoo and gets out of the way.</li> </ul> <p>At a high level, a boot session is:</p> <ol> <li>detect USB device</li> <li>match and probe with a Device Profile (DevPro)</li> <li>build stage0 from rootfs artifacts</li> <li>boot ephemerally over fastboot</li> <li>hand off runtime block export to smoo</li> </ol> <p>No flashing, no slot switching, no persistent install actions.</p>"},{"location":"dev/CONTRIBUTORS_INTRODUCTION/#first-60-seconds","title":"First 60 Seconds","text":"<pre><code>cargo run -p fastboop-cli -- --help\ncargo run -p fastboop-cli -- detect --help\ncargo run -p fastboop-cli -- stage0 --help\ncargo run -p fastboop-cli -- bootprofile --help\n</code></pre> <p>All four commands are safe read/help entrypoints and do not mutate devices.</p>"},{"location":"dev/CONTRIBUTORS_INTRODUCTION/#hard-rules","title":"Hard Rules","text":"<ul> <li>Keep the non-mutating invariant: no <code>flash</code>, <code>erase</code>, <code>format</code>, <code>set_active</code>, <code>oem</code>, or unlock/lock flows.</li> <li>Keep platform-agnostic behavior in core crates and transport/platform details in leaf crates.</li> <li>Respect <code>no_std + alloc</code> boundaries in core/proto crates.</li> <li>Prefer async-first code paths.</li> </ul>"},{"location":"dev/CONTRIBUTORS_INTRODUCTION/#where-things-live","title":"Where Things Live","text":"<ul> <li><code>devprofiles.d/</code>: built-in Device Profile YAML files.</li> <li><code>crates/fastboop-schema/</code>: DevPro + Boot Profile schema types.</li> <li><code>crates/fastboop-core/</code>: matching/probing/validation/runtime profile logic.</li> <li><code>crates/fastboop-stage0-generator/</code>: stage0 synthesis from rootfs + profile inputs.</li> <li><code>stage0/</code>: PID1 runtime that runs on device.</li> <li><code>cli/</code>: contributor-facing commands (<code>detect</code>, <code>stage0</code>, <code>boot</code>, <code>bootprofile</code>).</li> </ul>"},{"location":"dev/CONTRIBUTORS_INTRODUCTION/#quick-contributor-loop","title":"Quick Contributor Loop","text":"<pre><code>cargo fmt\ncargo check -p fastboop-cli\ncargo check -p fastboop-core\n</code></pre> <p>Then run path-specific checks from <code>HACKING.md</code> for whatever you touched.</p>"},{"location":"dev/CONTRIBUTORS_INTRODUCTION/#start-here-next","title":"Start Here Next","text":"<ul> <li>Device Profiles</li> <li>Boot Profiles</li> <li>Stage0</li> <li>Stage0 distribution</li> </ul>"},{"location":"dev/DEVICE_PROFILES/","title":"Device Profiles","text":"<p>Device Profiles (<code>DevPro</code>s) are fastboop's hardware playbook: they tell fastboop how to recognize a device and how to boot it safely without touching persistent storage.</p> <p>If you want concrete examples, start with the bundled profiles in <code>devprofiles.d/</code>. Those built-ins are always loaded by fastboop (CLI, desktop, and web).</p> <p>For local authoring and iteration, <code>fastboop-cli</code> also loads profiles from:</p> <ul> <li>colon-separated directories listed in <code>$FASTBOOP_SCHEMA_PATH</code></li> <li><code>$XDG_CONFIG_HOME/fastboop/devpro</code> (or <code>~/.config/fastboop/devpro</code>)</li> <li><code>/usr/share/fastboop/devpro</code></li> </ul> <p><code>DevPro</code>s describe how to locate a particular device in its bootloader state, capture the constraints of that environment, and define Stage0 requirements. There is no distro, installer, or user policy here.</p>"},{"location":"dev/DEVICE_PROFILES/#minimal-shape","title":"Minimal Shape","text":"<pre><code>id: oneplus-fajita\ndisplay_name: OnePlus 6T\ndevicetree_name: qcom/sdm845-oneplus-fajita\n\nmatch:\n  - fastboot:\n      vid: 0x18d1\n      pid: 0xd00d\n\nprobe:\n  - fastboot.getvar: product\n    equals: sdm845\n  - fastboot.getvar: partition-type:aging\n    exists:\n\nboot:\n  fastboot_boot:\n    android_bootimg:\n      header_version: 2\n      page_size: 4096\n      kernel_offset: 0x00008000\n\n      kernel:\n        encoding: image.gz\n\nstage0:\n  kernel_modules:\n    # This is the core set for a working UDC.\n    - dwc3\n    - dwc3-qcom\n    - dwc3-qcom-legacy\n    - phy-qcom-qusb2\n    - nvmem_qfprom\n    - i2c-qcom-geni\n    - pinctrl-sdm845\n    - gcc-sdm845\n    - qnoc-sdm845\n\n    # This isn't required for UDC, but needs to load\n    # early to avoid deferred-probe timeouts on arm-smmu.\n    - gpucc-sdm845\n</code></pre>"},{"location":"dev/DEVICE_PROFILES/#match","title":"Match","text":"<p><code>match</code> is the cheap USB prefilter used before deeper probing.</p> <p>For fastboot profiles, this is primarily USB VID/PID tuples. fastboop uses these tuples to decide which devices to probe, and web targets use the same tuples when requesting USB device access.</p> <p><code>match</code> is not the final identity check; <code>probe</code> is.</p> <p>Guidelines:</p> <ul> <li>List the exact VID/PID pair(s) used by this profile's bootloader mode.</li> <li>Similar devices may share the same VID/PID, we disambiguate in <code>probe</code>.</li> </ul>"},{"location":"dev/DEVICE_PROFILES/#probe","title":"Probe","text":"<p><code>probe</code> is the authoritative identity check.</p> <p>Probe steps are evaluated in order and should be read-only checks (<code>fastboot getvar ...</code>). If any required step fails, the profile does not match.</p> <p>Current probe primitives in schema are:</p> <ul> <li><code>equals</code></li> <li><code>not_equals</code></li> <li><code>exists</code></li> <li><code>not_exists</code></li> </ul> <p>Practical guidance:</p> <ul> <li>Put highly discriminating checks early to fail fast.</li> <li>Use multiple checks when one getvar is ambiguous across sibling devices.</li> </ul>"},{"location":"dev/DEVICE_PROFILES/#boot","title":"Boot","text":"<p><code>boot</code> describes what the bootloader will accept for ephemeral RAM boot.</p> <p>For current fastboop flows, this is <code>boot.fastboot_boot.android_bootimg</code>. This section captures concrete constraints (for example <code>header_version</code>, <code>page_size</code>, kernel encoding) so payload generation can be deterministic.</p> <p>Treat this as a hardware contract, not distro policy:</p> <ul> <li>Include fields required by the target bootloader.</li> <li>Keep values factual to observed device behavior.</li> <li>Avoid adding logic that belongs in Boot Profiles or stage0 generation.</li> </ul>"},{"location":"dev/DEVICE_PROFILES/#stage0-hints","title":"Stage0 Hints","text":"<p><code>stage0.kernel_modules</code> lists module requirements needed for reliable gadget/runtime bring-up. Keep this list focused: enough for consistent boot/handoff, not a generic module wishlist.</p> <p>As always, keep profiles non-mutating: no write/flash semantics.</p>"},{"location":"dev/DEVICE_PROFILES/#building-a-new-device-profile","title":"Building a new Device Profile","text":"<p>Start from a profile for a similar device in <code>devprofiles.d/</code>. Copy it to <code>~/.config/fastboop/devpro/your-device.yaml</code> and update the <code>id:</code> + <code>display_name:</code> + <code>devicetree_name:</code> fields.</p> <p>Ensure <code>match</code> + <code>probe</code> match your device. Test with the real device:</p> <pre><code>RUST_LOG=trace fastboop detect --device-profile your-device\n</code></pre> <p>Smoke-test payload generation with <code>fastboop boot</code> or <code>fastboop stage0</code> (if you have a rootfs to test with):</p> <pre><code># generate just the stage0 payload:\nfastboop stage0 --device-profile your-device rootfs.img\n\n# or the entire boot artifact:\nfastboop boot rootfs.img --device-profile your-device --output /tmp/boot.img\n</code></pre>"},{"location":"dev/DEVICE_PROFILES/#source-of-truth","title":"Source of Truth","text":"<ul> <li>Schema types: <code>crates/fastboop-schema/src/lib.rs</code></li> <li>Built-in profiles (latest on main): <code>devprofiles.d/</code></li> <li>Profile loading logic: <code>cli/src/devpros.rs</code></li> </ul>"},{"location":"dev/STAGE0/","title":"Stage0","text":"<p>Stage0 is the minimal initramfs fastboop synthesizes and boots ephemerally.</p> <p>Its job is short and strict: bring up gadget runtime, mount exported root, and exec distro init.</p>"},{"location":"dev/STAGE0/#source-of-truth","title":"Source of Truth","text":"<ul> <li>Runtime PID1 flow: <code>stage0/src/main.rs</code></li> <li>Stage0 assembly: <code>crates/fastboop-stage0-generator</code></li> <li>CLI entrypoint: <code>cli/src/commands/stage0.rs</code></li> <li>Distribution contract: <code>docs/dev/STAGE0_DISTRIBUTION.md</code></li> </ul>"},{"location":"dev/STAGE0/#contract","title":"Contract","text":"<p>Stage0 PID1 (<code>fastboop-stage0</code>) does this in order:</p> <ol> <li>mount <code>/proc</code>, <code>/sys</code>, <code>/dev</code>, <code>/run</code></li> <li>load required kernel modules</li> <li>configure configfs/FunctionFS and spawn embedded <code>smoo-gadget-app</code></li> <li>wait for exported block device (<code>/dev/ublkb0</code>)</li> <li>mount lower root (<code>erofs</code> or <code>ext4</code>) + tmpfs upper overlay</li> <li>switch root and <code>exec</code> init (<code>/lib/systemd/systemd</code>, <code>/usr/lib/systemd/systemd</code>, or <code>/sbin/init</code>)</li> </ol> <p>If gadget startup or handoff fails, stage0 fails loudly.</p>"},{"location":"dev/STAGE0/#inputs","title":"Inputs","text":"<ul> <li>Device Profile (<code>stage0.kernel_modules</code>, <code>stage0.inject_mac</code>)</li> <li>Boot Profile stage0 additions (extra modules, overlays, per-device cmdline)</li> <li>CLI overrides (<code>--dtb</code>, <code>--dtbo</code>, <code>--require-module</code>, <code>--cmdline-append</code>, <code>--serial</code>)</li> <li>Rootfs artifact source (direct image or compiled Boot Profile)</li> </ul>"},{"location":"dev/STAGE0/#settings-channel","title":"Settings Channel","text":"<p>Stage0 reads runtime settings from files under <code>/etc/stage0</code> in the generated initramfs.</p> <p>Notable keys include:</p> <ul> <li><code>stage0.rootfs</code> (required)</li> <li><code>ostree</code></li> <li><code>smoo.acm</code>, <code>smoo.queue_count</code>, <code>smoo.queue_depth</code>, <code>smoo.max_io_bytes</code></li> <li><code>firstboot.locale</code>, <code>firstboot.locale-messages</code>, <code>firstboot.keymap</code>, <code>firstboot.timezone</code></li> </ul>"},{"location":"dev/STAGE0/#non-goals","title":"Non-Goals","text":"<ul> <li>no flashing/partitioning/persistent writes</li> <li>no installer behavior</li> <li>no interactive rescue environment</li> <li>no distro policy engine</li> </ul>"},{"location":"dev/STAGE0/#how-to-bang-on-it","title":"How To Bang On It","text":"<pre><code># build stage0 initrd only\ncargo run -p fastboop-cli -- stage0 &lt;rootfs-or-bootprofile&gt; --device-profile &lt;id&gt; &gt; /tmp/stage0.cpio\n\n# build full boot payload without touching a device\ncargo run -p fastboop-cli -- boot &lt;rootfs-or-bootprofile&gt; --device-profile &lt;id&gt; --output /tmp/boot.img\n\n# targeted compile checks\ncargo check -p fastboop-stage0\ncargo check -p fastboop-stage0-generator\n</code></pre>"},{"location":"dev/STAGE0_DISTRIBUTION/","title":"Stage0 Distribution","text":"<p>This document defines how static stage0 binaries are produced and consumed across CI, release assets, and downstream packaging.</p>"},{"location":"dev/STAGE0_DISTRIBUTION/#artifact-contract","title":"Artifact Contract","text":"<p>Release assets include first-class stage0 static binaries:</p> <ul> <li><code>fastboop-stage0-x86_64-unknown-linux-musl</code></li> <li><code>fastboop-stage0-aarch64-unknown-linux-musl</code></li> </ul> <p>For tag <code>vX.Y.Z</code> (or <code>vX.Y.Z-rc.N</code>), assets are published alongside other release artifacts:</p> <ul> <li><code>https://github.com/samcday/fastboop/releases/download/vX.Y.Z/fastboop-stage0-x86_64-unknown-linux-musl</code></li> <li><code>https://github.com/samcday/fastboop/releases/download/vX.Y.Z/fastboop-stage0-aarch64-unknown-linux-musl</code></li> </ul> <p>Checksums are recorded in release <code>SHA256SUMS</code>.</p>"},{"location":"dev/STAGE0_DISTRIBUTION/#embed-modes","title":"Embed Modes","text":"<p><code>crates/fastboop-stage0-generator/build.rs</code> supports two embed modes:</p> <ol> <li><code>FASTBOOP_STAGE0_EMBED_PATH</code> set: copy the provided prebuilt stage0 binary and embed it.</li> <li><code>FASTBOOP_STAGE0_EMBED_PATH</code> unset: run the local nested stage0 sub-build for contributor convenience.</li> </ol> <p>Optional knobs for nested sub-builds:</p> <ul> <li><code>FASTBOOP_STAGE0_TARGET</code> (default <code>aarch64-unknown-linux-musl</code>)</li> <li><code>FASTBOOP_STAGE0_CARGO</code> (default inherited <code>cargo</code>)</li> </ul> <p>This preserves local <code>cargo build -p fastboop-cli</code> round-trips while allowing distro/release flows to consume prebuilt stage0 assets.</p>"},{"location":"dev/STAGE0_DISTRIBUTION/#ci-and-release-flow","title":"CI and Release Flow","text":"<ul> <li><code>.github/workflows/ci.yml</code> builds stage0 static artifacts in a dedicated <code>stage0-static</code> matrix.</li> <li><code>.github/workflows/release.yml</code> runs <code>stage0-preflight</code> before downstream packaging jobs.</li> <li><code>stage0-preflight</code> verifies both required stage0 artifacts exist and are static/static-pie linked.</li> <li>Release asset fan-in includes stage0 binaries and <code>SHA256SUMS</code>.</li> </ul>"},{"location":"dev/STAGE0_DISTRIBUTION/#downstream-packaging","title":"Downstream Packaging","text":"<ul> <li>Debian workflow: downloads <code>fastboop-stage0-aarch64</code> artifact and exports <code>FASTBOOP_STAGE0_EMBED_PATH</code> before package build.</li> <li>Alpine workflow: same release-mode artifact flow via <code>FASTBOOP_STAGE0_EMBED_PATH</code>.</li> <li>RPM spec: exports <code>FASTBOOP_STAGE0_EMBED_PATH</code> when either:</li> <li><code>--define 'fastboop_stage0_embed_path /path/to/fastboop-stage0-aarch64-unknown-linux-musl'</code> is passed, or</li> <li><code>%{_sourcedir}/fastboop-stage0-aarch64-unknown-linux-musl</code> exists.</li> </ul> <p>If no prebuilt stage0 path is provided, packaging falls back to the nested sub-build behavior.</p>"},{"location":"dev/STAGE0_DISTRIBUTION/#armv7-status","title":"Armv7 Status","text":"<p>Issue #13 allows <code>armv7-unknown-linux-musleabihf</code> or documented equivalent. Current release gating intentionally uses x86_64+aarch64 only.</p> <p>Reason: upstream <code>io-uring</code> target checks currently block reliable armv7 stage0 static artifact production in CI without additional architecture-specific work. Armv7 remains deferred follow-up scope.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/","title":"DevPro (device profiles) \u2014 fastboop v0","text":"<p>This document freezes the v0 assumptions for DevPro in fastboop.</p> <p>If you are reading this while implementing code: you are allowed to stop thinking. This is the box. Stay inside it.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#example-devpro-v0-schema-sketch","title":"Example DevPro (v0 schema sketch)","text":"<p>Target shape for a single fastboot-boot DevPro:</p> <pre><code>id: oneplus-fajita\ndisplay_name: OnePlus 6T\ndevicetree_name: qcom/sdm845-oneplus-fajita\n\nmatch:\n  - fastboot:\n      vid: 0x18d1\n      pid: 0xd00d\n\nprobe:\n  - fastboot.getvar: product\n    equals: sdm845\n  - fastboot.getvar: partition-type:aging\n    exists:\n\nboot:\n  fastboot_boot:\n    android_bootimg:\n      header_version: 2\n      page_size: 4096\n      base: 0x00000000\n      kernel_offset: 0x00008000\n\n    limits:\n      max_kernel_bytes: 16777216\n      max_initrd_bytes: 67108864\n      max_total_bytes: 83886080\n\n    kernel:\n      encoding: image.gz+dtb\n\n    cmdline_append: \"console=ttyMSM0,115200n8\"\n\nstage0:\n  # extra kernel modules that are needed for UDC to come up\n  kernel_modules: [dwc3, phy-qcom-qusb2, nvmem_qfprom]\n  inject_mac:\n    wifi: qcom,wcn3990-wifi\n    bluetooth: qcom,wcn3990-bt\n</code></pre> <p>This is descriptive: it states what the vendor bootloader accepts and how to prove identity. It does not add logic beyond match \u2192 probe \u2192 fastboot RAM boot.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#purpose","title":"Purpose","text":"<p>A DevPro describes how a specific class of device can be booted non\u2011mutatingly from a vendor bootloader over USB.</p> <p>A DevPro answers exactly one question:</p> <p>\u201cIf I am holding a USB handle to a device in vendor boot mode, can I safely boot something into RAM, and if so, how?\u201d</p> <p>A DevPro does not describe: - what OS or distro is booted - how installation works - how persistent storage is modified - how stage0 is implemented internally</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#nonmutating-invariant-hard-rule","title":"Non\u2011mutating invariant (hard rule)","text":"<p>fastboop must never perform persistent actions.</p> <p>Disallowed forever in v0: - <code>flash</code>, <code>erase</code>, <code>format</code> - slot changes (<code>set_active</code>) - unlock / lock - AVB / verity toggles - vendor <code>oem</code> commands</p> <p>Allowed: - read\u2011only probe commands (e.g. <code>fastboot getvar</code>) - ephemeral RAM boot (<code>fastboot boot</code>)</p> <p>If a device cannot be booted this way, it is out of scope.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#devpro-responsibilities","title":"DevPro responsibilities","text":"<p>A DevPro contains:</p> <ol> <li>Match rules</li> <li> <p>How to cheaply identify candidate devices (USB VID/PID, protocol)</p> </li> <li> <p>Probe rules</p> </li> <li>How to confirm the exact device identity</li> <li> <p>Optional capture of informational fields (bootloader version, product name)</p> </li> <li> <p>Boot description</p> </li> <li>Which non\u2011mutating boot mechanism is used</li> <li>What payload format is accepted</li> <li>Size / layout constraints enforced by the vendor bootloader</li> </ol> <p>That is all.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#what-devpro-explicitly-does-not-contain","title":"What DevPro explicitly does not contain","text":"<p>A DevPro must not include:</p> <ul> <li>rootfs selection logic</li> <li>distro\u2011specific behavior</li> <li>package names</li> <li>stage0 construction rules</li> <li>user choices (desktop environment, locale, etc.)</li> </ul> <p>Those belong elsewhere.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#stage0-mac-injection","title":"Stage0 MAC injection","text":"<p>Optional <code>stage0.inject_mac</code> entries identify target nodes by <code>compatible</code> string and inject deterministic addresses into the DTB used by stage0:</p> <ul> <li><code>wifi</code> writes <code>local-mac-address</code> using MSB order</li> <li><code>bluetooth</code> writes <code>local-bd-address</code> using LSB order</li> </ul> <p>Both fields are optional; omit <code>stage0.inject_mac</code> entirely if no injection is needed.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#v0-single-boot-mechanism","title":"v0: single boot mechanism","text":"<p>In v0, each DevPro describes exactly one boot mechanism.</p> <p>There is no <code>oneOf</code>, no fallback matrix, no multi\u2011format negotiation.</p> <p>If a device needs a different format later, that is a breaking schema change.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#v0-boot-mechanism-fastboot-ram-boot","title":"v0 boot mechanism: fastboot RAM boot","text":"<p>The only supported boot mechanism in v0 is:</p> <ul> <li>Fastboot ephemeral boot (<code>fastboot boot &lt;payload&gt;</code>)</li> </ul> <p>This implies: - the payload is staged entirely in RAM - control transfers immediately to the payload - the vendor bootloader remains unmodified</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#payload-description-conceptual","title":"Payload description (conceptual)","text":"<p>A DevPro describes the outer container format accepted by the device.</p> <p>For v0, this is assumed to always be an Android boot image.</p> <p>Kernel encoding is specified as a single string (e.g. <code>image.gz+dtb</code>) because it defines how the kernel is placed inside the boot image.</p> <p>This schema describes what the device accepts, not how fastboop builds it.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#match-and-probe-semantics","title":"Match and probe semantics","text":""},{"location":"dev/attic/DEVICE_PROFILES-v0/#match","title":"Match","text":"<p>Match rules are cheap filters applied before opening the device:</p> <ul> <li>protocol (e.g. fastboot)</li> <li>USB VID/PID pairs</li> <li>optional interface constraints</li> </ul> <p>Match rules are used to: - build WebUSB <code>requestDevice()</code> filters - limit libusb enumeration - reduce unnecessary probe attempts</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#probe","title":"Probe","text":"<p>Probe rules are ordered, fail\u2011fast checks:</p> <ul> <li>typically <code>fastboot getvar &lt;name&gt;</code></li> <li>expected values must match</li> <li>probes may capture informational strings</li> </ul> <p>If any probe step fails, the DevPro does not match the device.</p> <p>Probe steps must be read\u2011only.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#chaining-and-reenumeration-future","title":"Chaining and re\u2011enumeration (future)","text":"<p>Some devices may require chaining into a better bootloader (e.g. U\u2011Boot or lk2nd) first.</p> <p>This is not required for v0, but DevPro design must not block it.</p> <p>Assumption: - fastboop core is a state machine - devices may disappear and re\u2011enumerate - DevPro matching/probing may occur multiple times per session</p> <p>Chaining is expressed as a boot session, not by mutating the device.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#error-handling-philosophy","title":"Error handling philosophy","text":"<p>DevPro failures should be: - explicit - explainable - surfaced to the caller/UI</p> <p>Examples: - \u201cDevice matches VID/PID but failed probe\u201d - \u201cPayload exceeds max_total_bytes\u201d - \u201cBoot mechanism not supported by this profile\u201d</p> <p>Silent fallback is forbidden.</p>"},{"location":"dev/attic/DEVICE_PROFILES-v0/#summary-the-mental-model","title":"Summary (the mental model)","text":"<ul> <li>DevPro = how to boot a device safely</li> <li>Rootfs + stage0 = what is booted</li> <li>fastboop = glue between vendor bootloader and smoo</li> <li>smoo = the gadget/export data plane stage0 relies on during handoff</li> </ul> <p>If you find yourself wanting to add more logic to DevPro: stop. You are probably about to violate v0.</p>"},{"location":"dev/attic/DIOXUS/","title":"Dioxus notes","text":"<p>You are an expert 0.7 Dioxus assistant. Dioxus 0.7 changes every api in dioxus. Only use this up to date documentation. <code>cx</code>, <code>Scope</code>, and <code>use_state</code> are gone</p> <p>Provide concise code examples with detailed descriptions</p>"},{"location":"dev/attic/DIOXUS/#dioxus-dependency","title":"Dioxus Dependency","text":"<p>You can add Dioxus to your <code>Cargo.toml</code> like this:</p> <pre><code>[dependencies]\ndioxus = { version = \"0.7.1\" }\n\n[features]\ndefault = [\"web\", \"webview\", \"server\"]\nweb = [\"dioxus/web\"]\nwebview = [\"dioxus/desktop\"]\nserver = [\"dioxus/server\"]\n</code></pre>"},{"location":"dev/attic/DIOXUS/#launching-your-application","title":"Launching your application","text":"<p>You need to create a main function that sets up the Dioxus runtime and mounts your root component.</p> <pre><code>use dioxus::prelude::*;\n\nfn main() {\n    dioxus::launch(App);\n}\n\n#[component]\nfn App() -&gt; Element {\n    rsx! { \"Hello, Dioxus!\" }\n}\n</code></pre> <p>Then serve with <code>dx serve</code>:</p> <pre><code>curl -sSL http://dioxus.dev/install.sh | sh\ndx serve\n</code></pre>"},{"location":"dev/attic/DIOXUS/#ui-with-rsx","title":"UI with RSX","text":"<pre><code>rsx! {\n    div {\n        class: \"container\", // Attribute\n        color: \"red\", // Inline styles\n        width: if condition { \"100%\" }, // Conditional attributes\n        \"Hello, Dioxus!\"\n    }\n    // Prefer loops over iterators\n    for i in 0..5 {\n        div { \"{i}\" } // use elements or components directly in loops\n    }\n    if condition {\n        div { \"Condition is true!\" } // use elements or components directly in conditionals\n    }\n\n    {children} // Expressions are wrapped in brace\n    {(0..5).map(|i| rsx! { span { \"Item {i}\" } })} // Iterators must be wrapped in braces\n}\n</code></pre>"},{"location":"dev/attic/DIOXUS/#assets","title":"Assets","text":"<p>The asset macro can be used to link to local files to use in your project. All links start with <code>/</code> and are relative to the root of your project.</p> <pre><code>rsx! {\n    img {\n        src: asset!(\"/assets/image.png\"),\n        alt: \"An image\",\n    }\n}\n</code></pre>"},{"location":"dev/attic/DIOXUS/#styles","title":"Styles","text":"<p>The <code>document::Stylesheet</code> component will inject the stylesheet into the <code>&lt;head&gt;</code> of the document</p> <pre><code>rsx! {\n    document::Stylesheet {\n        href: asset!(\"/assets/styles.css\"),\n    }\n}\n</code></pre>"},{"location":"dev/attic/DIOXUS/#components","title":"Components","text":"<p>Components are the building blocks of apps</p> <ul> <li>Component are functions annotated with the <code>#[component]</code> macro.</li> <li>The function name must start with a capital letter or contain an underscore.</li> <li>A component re-renders only under two conditions:<ol> <li>Its props change (as determined by <code>PartialEq</code>).</li> <li>An internal reactive state it depends on is updated.</li> </ol> </li> </ul> <pre><code>#[component]\nfn Input(mut value: Signal&lt;String&gt;) -&gt; Element {\n    rsx! {\n        input {\n            value,\n            oninput: move |e| {\n                *value.write() = e.value();\n            },\n            onkeydown: move |e| {\n                if e.key() == Key::Enter {\n                    value.write().clear();\n                }\n            },\n        }\n    }\n}\n</code></pre> <p>Each component accepts function arguments (props)</p> <ul> <li>Props must be owned values, not references. Use <code>String</code> and <code>Vec&lt;T&gt;</code> instead of <code>&amp;str</code> or <code>&amp;[T]</code>.</li> <li>Props must implement <code>PartialEq</code> and <code>Clone</code>.</li> <li>To make props reactive and copy, you can wrap the type in <code>ReadOnlySignal</code>. Any reactive state like memos and resources that read <code>ReadOnlySignal</code> props will automatically re-run when the prop changes.</li> </ul>"},{"location":"dev/attic/DIOXUS/#state","title":"State","text":"<p>A signal is a wrapper around a value that automatically tracks where it's read and written. Changing a signal's value causes code that relies on the signal to rerun.</p>"},{"location":"dev/attic/DIOXUS/#local-state","title":"Local State","text":"<p>The <code>use_signal</code> hook creates state that is local to a single component. You can call the signal like a function (e.g. <code>my_signal()</code>) to clone the value, or use <code>.read()</code> to get a reference. <code>.write()</code> gets a mutable reference to the value.</p> <p>Use <code>use_memo</code> to create a memoized value that recalculates when its dependencies change. Memos are useful for expensive calculations that you don't want to repeat unnecessarily.</p> <pre><code>#[component]\nfn Counter() -&gt; Element {\n    let mut count = use_signal(|| 0);\n    let mut doubled = use_memo(move || count() * 2); // doubled will re-run when count changes because it reads the signal\n\n    rsx! {\n        h1 { \"Count: {count}\" } // Counter will re-render when count changes because it reads the signal\n        h2 { \"Doubled: {doubled}\" }\n        button {\n            onclick: move |_| *count.write() += 1, // Writing to the signal rerenders Counter\n            \"Increment\"\n        }\n        button {\n            onclick: move |_| count.with_mut(|count| *count += 1), // use with_mut to mutate the signal\n            \"Increment with with_mut\"\n        }\n    }\n}\n</code></pre>"},{"location":"dev/attic/DIOXUS/#context-api","title":"Context API","text":"<p>The Context API allows you to share state down the component tree. A parent provides the state using <code>use_context_provider</code>, and any child can access it with <code>use_context</code></p> <pre><code>#[component]\nfn App() -&gt; Element {\n    let mut theme = use_signal(|| \"light\".to_string());\n    use_context_provider(|| theme); // Provide a type to children\n    rsx! { Child {} }\n}\n\n#[component]\nfn Child() -&gt; Element {\n    let theme = use_context::&lt;Signal&lt;String&gt;&gt;(); // Consume the same type\n    rsx! {\n        div {\n            \"Current theme: {theme}\"\n        }\n    }\n}\n</code></pre>"},{"location":"dev/attic/DIOXUS/#async","title":"Async","text":"<p>For state that depends on an asynchronous operation (like a network request), Dioxus provides a hook called <code>use_resource</code>. This hook manages the lifecycle of the async task and provides the result to your component.</p> <ul> <li>The <code>use_resource</code> hook takes an <code>async</code> closure. It re-runs this closure whenever any signals it depends on (reads) are updated</li> <li>The <code>Resource</code> object returned can be in several states when read:</li> <li><code>None</code> if the resource is still loading</li> <li><code>Some(value)</code> if the resource has successfully loaded</li> </ul> <pre><code>let mut dog = use_resource(move || async move {\n    // api request\n});\n\nmatch dog() {\n    Some(dog_info) =&gt; rsx! { Dog { dog_info } },\n    None =&gt; rsx! { \"Loading...\" },\n}\n</code></pre>"},{"location":"dev/attic/DIOXUS/#routing","title":"Routing","text":"<p>All possible routes are defined in a single Rust <code>enum</code> that derives <code>Routable</code>. Each variant represents a route and is annotated with <code>#[route(\"/path\")]</code>. Dynamic Segments can capture parts of the URL path as parameters by using <code>:name</code> in the route string. These become fields in the enum variant.</p> <p>The <code>Router&lt;Route&gt; {}</code> component is the entry point that manages rendering the correct component for the current URL.</p> <p>You can use the <code>#[layout(NavBar)]</code> to create a layout shared between pages and place an <code>Outlet&lt;Route&gt; {}</code> inside your layout component. The child routes will be rendered in the outlet.</p> <pre><code>#[derive(Routable, Clone, PartialEq)]\nenum Route {\n    #[layout(NavBar)] // This will use NavBar as the layout for all routes\n        #[route(\"/\")]\n        Home {},\n        #[route(\"/blog/:id\")] // Dynamic segment\n        BlogPost { id: i32 },\n}\n\n#[component]\nfn NavBar() -&gt; Element {\n    rsx! {\n        a { href: \"/\", \"Home\" }\n        Outlet&lt;Route&gt; {} // Renders Home or BlogPost\n    }\n}\n\n#[component]\nfn App() -&gt; Element {\n    rsx! { Router::&lt;Route&gt; {} }\n}\n</code></pre> <pre><code>dioxus = { version = \"0.7.1\", features = [\"router\"] }\n</code></pre>"},{"location":"dev/attic/DIOXUS/#fullstack","title":"Fullstack","text":"<p>Fullstack enables server rendering and ipc calls. It uses Cargo features (<code>server</code> and a client feature like <code>web</code>) to split the code into a server and client binaries.</p> <pre><code>dioxus = { version = \"0.7.1\", features = [\"fullstack\"] }\n</code></pre>"},{"location":"dev/attic/DIOXUS/#server-functions","title":"Server Functions","text":"<p>Use the <code>#[post]</code> / <code>#[get]</code> macros to define an <code>async</code> function that will only run on the server. On the server, this macro generates an API endpoint. On the client, it generates a function that makes an HTTP request to that endpoint.</p> <pre><code>#[post(\"/api/double/:path/&amp;query\")]\nasync fn double_server(number: i32, path: String, query: i32) -&gt; Result&lt;i32, ServerFnError&gt; {\n    tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n    Ok(number * 2)\n}\n</code></pre>"},{"location":"dev/attic/DIOXUS/#hydration","title":"Hydration","text":"<p>Hydration is the process of making a server-rendered HTML page interactive on the client. The server sends the initial HTML, and then the client-side runs, attaches event listeners, and takes control of future rendering.</p>"},{"location":"dev/attic/DIOXUS/#errors","title":"Errors","text":"<p>The initial UI rendered by the component on the client must be identical to the UI rendered on the server.</p> <ul> <li>Use the <code>use_server_future</code> hook instead of <code>use_resource</code>. It runs the future on the server, serializes the result, and sends it to the client, ensuring the client has the data immediately for its first render.</li> <li>Any code that relies on browser-specific APIs (like accessing <code>localStorage</code>) must be run after hydration. Place this code inside a <code>use_effect</code> hook.</li> </ul>"},{"location":"dev/attic/STAGE0-v0/","title":"Stage0 \u2014 fastboop v0","text":"<p>This document freezes the v0 assumptions for stage0 in fastboop.</p> <p>If you are implementing stage0 and feel the urge to add features: stop. Stage0 exists to do one job and then get out of the way.</p>"},{"location":"dev/attic/STAGE0-v0/#purpose","title":"Purpose","text":"<p>Stage0 is a productionized initramfs synthesized by fastboop whose purpose is to:</p> <p>Boot the device kernel, run embedded smoo-gadget-app under stage0 PID1 supervision, mount the exported root, and exec distro init.</p> <p>Stage0 targets well-tested, understood platforms that we want to make boring. It assumes the host just booted it over the same USB link (e.g. <code>fastboot boot</code>) and should bring up smoo right away.</p> <p>Stage0 is not a distro. Stage0 is not an installer. Stage0 is not a rescue or bring-up shell. Stage0 is not persistent.</p>"},{"location":"dev/attic/STAGE0-v0/#scope-hard-limits","title":"Scope (hard limits)","text":"<p>Stage0 must do only the following:</p> <ol> <li>Mount minimal virtual filesystems (<code>/proc</code>, <code>/sys</code>, <code>/dev</code>, <code>/run</code>)</li> <li>Load a host-generated kernel module list deterministically (no <code>modprobe</code>)</li> <li>Configure gadget stack + FunctionFS, then spawn embedded <code>smoo-gadget-app</code></li> <li>Wait for smoo-exported block device and mount root (<code>erofs</code> lower + tmpfs <code>overlay</code> upper)</li> <li>Exec distro init (<code>/lib/systemd/systemd</code> or <code>/sbin/init</code>)</li> </ol> <p>Anything beyond this is out of scope for v0.</p>"},{"location":"dev/attic/STAGE0-v0/#non-goals","title":"Non-goals","text":"<p>Stage0 must not:</p> <ul> <li>Touch persistent storage</li> <li>Partition disks</li> <li>Contain distro logic</li> <li>Run installers</li> <li>Provide interactive shells or general toolboxes</li> <li>Handle user configuration</li> <li>Perform network configuration beyond what smoo requires</li> <li>Act as a bring-up/rescue environment or carry \u201cspicy\u201d debugging (LED/morse code)</li> </ul> <p>If you think stage0 should do one of these things, the answer is no.</p>"},{"location":"dev/attic/STAGE0-v0/#inputs-to-stage0-generation","title":"Inputs to stage0 generation","text":"<p>Stage0 is generated per device and per rootfs.</p> <p>fastboop provides stage0 generation with:</p> <ol> <li>DevPro-derived requirements</li> <li>Which kernel modules must be present for this device</li> <li> <p>Kernel command line additions</p> </li> <li> <p>Rootfs artifact</p> </li> <li>Source of the kernel image</li> <li> <p>Source of kernel modules (<code>/usr/lib/modules/&lt;kver&gt;</code> or equivalent)</p> </li> <li> <p>Boot constraints</p> </li> <li>Maximum payload sizes</li> <li>Accepted boot image format (e.g. android boot.img)</li> </ol>"},{"location":"dev/attic/STAGE0-v0/#userspace-contents","title":"Userspace contents","text":"<p>Stage0 userspace is intentionally hermetic and minimal.</p> <p>It contains:</p> <ul> <li><code>fastboop-stage0</code> (running as PID 1)</li> <li>embedded <code>smoo-gadget-app</code> runtime</li> <li>minimal directory layout to support module loading + FunctionFS:</li> <li><code>/sbin</code></li> <li><code>/lib</code></li> <li><code>/lib/modules</code></li> <li><code>/dev</code></li> <li><code>/proc</code></li> <li><code>/sys</code></li> </ul> <p>Stage0 must not rely on: - package managers - dynamic linking to rootfs libraries - distro-specific tooling - busybox/bash/general toolboxes</p> <p>All binaries included in stage0 must be self-contained and directly required to get smoo running.</p>"},{"location":"dev/attic/STAGE0-v0/#kernel-modules","title":"Kernel modules","text":"<p>Stage0 includes only the kernel modules required to:</p> <ul> <li>initialize the USB Device Controller (UDC)</li> <li>support USB gadget framework</li> <li>enable FunctionFS</li> <li>optionally enable <code>ublk</code> if required by smoo</li> </ul> <p>Module selection rules:</p> <ul> <li>The required module set is provided by the DevPro</li> <li>Dependencies are resolved via <code>modules.dep</code></li> <li>Modalias-based auto-discovery is explicitly out of scope for v0</li> </ul> <p>If a required module is missing from the rootfs, stage0 generation must fail explicitly.</p>"},{"location":"dev/attic/STAGE0-v0/#firmware-handling","title":"Firmware handling","text":"<p>Stage0 does not include firmware. Any firmware needed beyond the minimal UDC path must be provided in an <code>--augment</code> cpio or in the main rootfs.</p>"},{"location":"dev/attic/STAGE0-v0/#init-sequence-conceptual","title":"Init sequence (conceptual)","text":"<p>The <code>/init</code> entrypoint performs, in order:</p> <ol> <li>Mount <code>/proc</code>, <code>/sys</code>, <code>/dev</code></li> <li>Set up logging to <code>/dev/kmsg</code> (PID 1 behavior)</li> <li>Load required kernel modules (in dependency order) from the host-provided list</li> <li>Configure gadget + spawn <code>smoo-gadget-app</code></li> <li>Wait for exported block device and mount overlay root</li> <li>Exec distro init</li> </ol> <p>There is no full init system inside stage0. There is explicit supervision of the gadget child process. There is no interactive fallback path.</p> <p>If the gadget child exits unexpectedly before handoff, stage0 has failed.</p>"},{"location":"dev/attic/STAGE0-v0/#ostree-deployment-handoff-v0","title":"OSTree deployment handoff (v0)","text":"<p>If <code>/etc/stage0/ostree</code> is present, stage0 performs an OSTree-compatible handoff before execing distro init:</p> <ul> <li>resolve the <code>ostree</code> path in the mounted root and require it to point at a deployment   symlink target</li> <li>switch root into the resolved deployment path</li> <li>bind-mount physical root onto the deployment's <code>/sysroot</code></li> <li>bind-mount stateroot <code>/var</code> onto the deployment's <code>/var</code></li> <li>bind-mount <code>/boot</code> into deployment <code>/boot</code> when the shared-boot layout is   detected (<code>/boot/loader</code> symlink)</li> </ul> <p>This compatibility mode is intentionally limited to <code>ostree</code> path resolution and mount layout. It does not parse <code>prepare-root.conf</code> and does not implement composefs policy.</p>"},{"location":"dev/attic/STAGE0-v0/#stage0-settings-and-firstboot-credentials","title":"Stage0 settings and firstboot credentials","text":"<p>Stage0 runtime settings are sourced from file entries under <code>/etc/stage0/</code> in the generated initramfs, not from kernel cmdline.</p> <p>Examples:</p> <ul> <li><code>/etc/stage0/ostree</code></li> <li><code>/etc/stage0/smoo.acm</code></li> <li><code>/etc/stage0/smoo.queue_count</code></li> <li><code>/etc/stage0/smoo.queue_depth</code></li> <li><code>/etc/stage0/smoo.max_io_bytes</code></li> <li><code>/etc/stage0/smoo.log</code></li> </ul> <p>First-boot locale/keymap/timezone values are also written into <code>/etc/stage0</code> by the generator. Right before handing off to distro init, stage0 publishes them into <code>/run/credstore/firstboot.*</code> so systemd units using <code>ImportCredential=firstboot.*</code> can consume them.</p>"},{"location":"dev/attic/STAGE0-v0/#error-philosophy","title":"Error philosophy","text":"<p>Stage0 failures must be:</p> <ul> <li>deterministic</li> <li>early</li> <li>loud</li> </ul> <p>Examples: - missing kernel modules - payload exceeds size limits - incompatible kernel version - embedded smoo runtime failing before root handoff</p> <p>Silent degradation is forbidden.</p>"},{"location":"dev/attic/STAGE0-v0/#relationship-to-smoo","title":"Relationship to smoo","text":"<p>Stage0 exists only to get smoo running.</p> <p>Once stage0 has launched smoo and switched root: - smoo continues serving the block export path - userspace boot and system lifecycle belong to the booted distro</p> <p>Stage0 must not attempt to anticipate or replicate smoo behavior.</p> <p>Advanced users or distro integrators can build their own initrd (e.g. with mkosi) containing shells/toolboxes and a different smoo variant if they need a debug path. fastboop\u2019s stage0 remains the boring production path.</p>"},{"location":"dev/attic/STAGE0-v0/#summary-the-box","title":"Summary (the box)","text":"<ul> <li>Stage0 = minimal initramfs</li> <li>Purpose = bring up USB gadget, launch embedded smoo, mount root, exec init</li> <li>Inputs = DevPro + rootfs + boot constraints</li> <li>Outputs = ephemeral boot payload</li> <li>Lifetime = seconds</li> </ul> <p>If stage0 is doing more than this: it is wrong.</p>"},{"location":"plans/CHANNELS/","title":"Channels Plan (v0)","text":""},{"location":"plans/CHANNELS/#goal","title":"Goal","text":"<p>Move fastboop from a positional <code>rootfs</code> artifact model to a single <code>channel</code> input.</p> <p>Core model:</p> <ul> <li>A channel is just a stream of bytes.</li> <li>We do in-band autodetection on that stream.</li> <li>We do not model a separate concrete \"bundle\" container type.</li> <li>In later phases, we may accept out-of-band hints (for example mime-type), but byte-stream detection remains authoritative.</li> </ul>"},{"location":"plans/CHANNELS/#first-pass-focus-current","title":"First Pass Focus (Current)","text":"<ul> <li>[x] CLI-first delivery (<code>fastboop boot</code>, <code>fastboop stage0</code>).</li> <li>[x] Support naked artifact channels (recursive unwrap/sniff).</li> <li>[x] Support bootprofile-leading streams (<code>.bootpro</code> records at stream head).</li> <li>[x] Channel-stream DevProfile records are wired in core/CLI and startup intake paths.</li> <li>[x] Desktop/web parity tracking is active.</li> <li>[ ] Desktop/web parity is complete enough to gate this first pass.</li> </ul> <p>This plan tracks the ongoing channel direction from issue <code>#20</code> and related bootprofile work.</p>"},{"location":"plans/CHANNELS/#non-negotiables","title":"Non-negotiables","text":"<ul> <li>Keep fastboop non-mutating (no flash/erase/format/slot toggles/unlock paths).</li> <li>Keep existing DevPro and Stage0 invariants.</li> <li>Keep behavior deterministic; fail loudly only when no valid channel content can be accepted.</li> <li>Preserve conventional-commit history hygiene across this track (each logical checkpoint should land as a focused <code>feat</code>/<code>fix</code>/<code>refactor</code> commit with intent-first message).</li> </ul>"},{"location":"plans/CHANNELS/#target-behavior","title":"Target Behavior","text":"<p>Given one <code>channel</code> input:</p> <ol> <li>Open it as a readable source (path/URL/stream).</li> <li>Attempt profile-record scan from stream head, forward-only, in best-effort/lossy mode:</li> <li>if next bytes decode as BootProfile binary record, accept and continue</li> <li>if next bytes decode as DevProfile binary record, accept and continue</li> <li>if next bytes are not a known profile-record header, stop scan and treat remaining bytes as artifact tail</li> <li>Validation/error boundary:</li> <li>if record decode/validation fails before any valid record is accepted, fail</li> <li>if one or more valid records were already accepted, stop at first invalid/truncated/non-decodable record and continue with trailing bytes; emit warning</li> <li>trailing zero-padding bytes from block-rounded reads are treated the same as other trailing junk: warning-only after at least one accepted record</li> <li>Session handling:</li> <li>accepted records are loaded into session-scoped in-memory state only</li> <li>no local persistence</li> <li>if DevProfiles were accepted from channel, constrain probe/match to those DevProfiles</li> <li>BootProfile choices are filtered by selected device compatibility</li> <li>Artifact handling:</li> <li>remaining bytes (if any) run through the recursive unwrap/sniff pipeline</li> <li>if no profile records are accepted at head, run unwrap/sniff from offset 0 as usual</li> </ol> <p>Example this model must support:</p> <ul> <li>prepend one or more DevProfile/BootProfile binary records to a normal <code>.xz</code> rootfs artifact</li> <li>treat the whole byte stream as one valid channel</li> </ul>"},{"location":"plans/CHANNELS/#record-stream-classification-contract-draft-v1","title":"Record + Stream Classification Contract (Draft v1)","text":"<p>Channel intake is split into two deterministic parts:</p> <ol> <li>Profile-record head scan (offset-relative, forward-only)</li> <li>Artifact classifier (bounded prefix + fixed probe order)</li> </ol> <p>Profile-record headers:</p> <ul> <li>BootProfile v2: <code>FBOOPROF</code> magic + <code>format_version=2</code></li> <li>DevProfile v1: <code>FBOODEVP</code> magic + <code>format_version=1</code></li> </ul> <p>Artifact classifier:</p> <ul> <li>Prefix window: first <code>64 KiB</code> (<code>CHANNEL_SNIFF_PREFIX_LEN</code> in <code>fastboop-core</code>).</li> <li>Probe order (first match wins):</li> <li>XZ (<code>FD 37 7A 58 5A 00</code>)</li> <li>ZIP (<code>PK\\x03\\x04</code>, <code>PK\\x05\\x06</code>, <code>PK\\x07\\x08</code>)</li> <li>Android sparse (<code>0xED26FF3A</code> LE)</li> <li>GPT (<code>EFI PART</code> at LBA1 / offset 512)</li> <li>ISO9660 (<code>CD001</code> at sector 16 descriptor)</li> <li>EROFS (superblock magic <code>0xE0F5E1E2</code> at offset 1024)</li> <li>ext4 (<code>0xEF53</code> at offset 1080)</li> <li>FAT (<code>FAT12/16/32</code> markers + <code>0x55AA</code>)</li> <li>MBR (<code>0x55AA</code> + non-empty partition entry type)</li> </ul> <p>Notes:</p> <ul> <li>Wrappers/containers are intentionally tested before filesystems.</li> <li>FAT is checked before generic MBR to avoid false positives on FAT boot sectors.</li> <li>Unknown/unsupported formats fail explicitly; no silent fallback.</li> </ul>"},{"location":"plans/CHANNELS/#scope","title":"Scope","text":"<ul> <li>Replace <code>rootfs</code> / <code>rootfs_artifact</code> naming with <code>channel</code> across CLI + desktop + web + shared UI structs.</li> <li>Keep and extend channel sniff/dispatch path in core.</li> <li>Add profile-record head scanning support for mixed BootProfile/DevProfile streams.</li> <li>Add session-scoped loading of accepted profile records (no local persistence).</li> <li>Keep artifact unwrap path working for existing known formats.</li> <li>Keep simple multi-filesystem coalescing as the final phase.</li> <li><code>fastboop-core</code> now owns byte-level channel stream-head scan (<code>boot+dev</code>) and boot-profile selection logic; CLI/desktop/web already consume these helpers, with a single reusable intake entrypoint still queued for phase 2.</li> </ul>"},{"location":"plans/CHANNELS/#out-of-scope-for-this-iteration","title":"Out of Scope (for this iteration)","text":"<ul> <li>Full policy engine for artifact ranking beyond deterministic heuristics.</li> <li>Complex union/overlay semantics between filesystems.</li> <li>Any mutating install workflow.</li> <li>Out-of-band channel hint protocol (mime-types, sidecar manifests, etc.) beyond future design notes.</li> </ul>"},{"location":"plans/CHANNELS/#phased-rollout","title":"Phased Rollout","text":""},{"location":"plans/CHANNELS/#phase-0-cli-first-pass-mostly-landed","title":"Phase 0: CLI First Pass (Mostly Landed)","text":"<ul> <li><code>fastboop boot</code> and <code>fastboop stage0</code> accept channel artifact intake.</li> <li>Bootprofile-leading streams at channel head are parsed and validated.</li> <li>Trailing bytes continue through artifact unwrap/sniff.</li> <li>Deterministic selection and explicit <code>--boot-profile</code> behavior are in place.</li> </ul> <p>Deliverable: CLI can boot from either plain artifact channels or bootprofile-leading streams, without local persistence.</p> <p>Status:</p> <ul> <li>[x] CLI <code>boot</code>/<code>stage0</code> channel artifact intake through recursive unwrap/sniff.</li> <li>[x] CLI bootprofile-leading stream head parsing.</li> <li>[x] CLI boot profile compatibility uses <code>stage0.devices</code> rule (<code>{}</code> =&gt; all devices).</li> <li>[x] CLI explicit <code>--boot-profile</code> selection.</li> <li>[x] CLI stream EOF/tail detection uses exact channel byte size.</li> <li>[x] BootProfile schema/validation supports casync <code>.caibx</code> sources (including nested GPT selection).</li> <li>[x] Channel-stream DevProfile record ingestion (core parser + CLI/session constraint wiring).</li> <li>[ ] Desktop/web parity with CLI channel intake behavior.</li> <li>[x] Desktop/web startup intake now uses best-effort/lossy profile stream-head parsing semantics (warning-only when trailing junk appears after accepted records).</li> <li>[x] Desktop/web startup now retains channel stream-head metadata for session use and probe filtering.</li> <li>[x] Desktop/web probe candidate filtering now narrows to BootProfile-referenced device IDs (<code>stage0.devices</code>) unless wildcard/all-device behavior applies.</li> <li>[x] Desktop/web session boot config now displays the selected BootProfile and requires an explicit pick when multiple compatible profiles exist.</li> <li>[ ] Desktop/web UI boot flows still have partial BootProfile rootfs source support when booting without trailing artifact payload (desktop: HTTP-only; web: HTTP/casync plus wrapper pipelines <code>xz</code>/<code>android_sparseimg</code>/<code>mbr</code>/<code>gpt</code>, with <code>file</code> limited to <code>web-file://</code> handles due browser sandbox constraints, and OSTree deployment auto-detection now wired for web BootProfile <code>rootfs.ostree</code> no-tail flow).</li> </ul>"},{"location":"plans/CHANNELS/#phase-1-surface-migration-rootfs-channel","title":"Phase 1: Surface Migration (<code>rootfs</code> -&gt; <code>channel</code>)","text":"<ul> <li>Rename user-facing parameters and config fields to <code>channel</code>.</li> <li>Project is unreleased: do not add compatibility aliases or deprecation warnings.</li> <li>Session startup requires non-empty <code>channel</code> in CLI/desktop/web.</li> </ul> <p>Deliverable: all frontends treat channel as the single source input.</p> <p>Status:</p> <ul> <li>[x] User-facing startup/config inputs in CLI/desktop/web are channel-first.</li> <li>[x] <code>rootfs</code>/<code>rootfs_artifact</code> compatibility aliases were intentionally not added.</li> <li>[x] Session startup requires a non-empty <code>channel</code> in CLI/desktop/web.</li> </ul>"},{"location":"plans/CHANNELS/#phase-2-core-channel-intake-unification","title":"Phase 2: Core Channel Intake Unification","text":"<ul> <li>Provide one shared channel intake entrypoint for CLI/desktop/web.</li> <li>Keep profile-record scan + artifact unwrap logic consistent across frontends.</li> <li>Keep probe-by-signature behavior (not extension-driven).</li> </ul> <p>Phase gate:</p> <ul> <li>Shared path passes fixture parity tests and replaces duplicated CLI intake code.</li> <li>[x] Core stream-head scan and selection module exists in <code>fastboop-core</code>.</li> <li>[x] CLI resolves profile stream head and selection through core module (<code>read_boot_profile_stream_head</code>, <code>select_boot_profile_for_device</code>).</li> <li>[ ] Desktop and web adopt the same core helpers.</li> <li>[x] Desktop/web now consume <code>read_channel_stream_head</code> output and use core BootProfile compatibility rules for runtime selection.</li> <li>[ ] Shared reusable channel-intake entrypoint (single implementation across CLI/desktop/web) is still pending.</li> </ul> <p>Deliverable: one reusable channel intake stack for all runtimes.</p>"},{"location":"plans/CHANNELS/#phase-3-devprofile-records-in-channel-streams","title":"Phase 3: DevProfile Records in Channel Streams","text":"<ul> <li>Finalize DevProfile binary framing contract (magic + format version).</li> <li>Implement DevProfile decode/validate functions parallel to BootProfile binary path.</li> <li>Support mixed/interleaved stream heads (<code>devpro</code>, <code>bootpro</code>, <code>devpro</code>, ...).</li> <li>Build session model from accepted head records:</li> <li>accepted DevProfiles</li> <li>accepted BootProfiles</li> <li>accepted/rejected counters and reasons</li> <li>Constrain matching/probing to channel DevProfiles when present.</li> <li>Keep all handling side-effect free and non-persistent.</li> </ul> <p>Status:</p> <ul> <li>[x] DevProfile binary framing contract is finalized (<code>FBOODEVP</code> + <code>format_version=1</code>).</li> <li>[x] DevProfile prefix decode support is implemented in <code>fastboop-core</code> stream-head parsing.</li> <li>[x] Mixed/interleaved stream heads (<code>devpro+bootpro</code>, <code>bootpro+devpro</code>) are exercised and deterministic.</li> <li>[x] Session intake now carries accepted DevProfiles + BootProfiles + consumed bytes + warning count.</li> <li>[ ] Rejected-record counters/reason details are still warning-count based (not fully structured yet).</li> <li>[ ] Probe narrowing by channel DevProfiles is not yet uniformly enforced across every frontend probe path.</li> <li>[x] Handling remains in-memory and non-persistent.</li> </ul> <p>Compatibility rule for BootProfile selection (v0):</p> <ul> <li>If <code>boot_profile.stage0.devices</code> is empty, the BootProfile is compatible with all known devices.</li> <li>Otherwise, compatible only when <code>selected_device_profile.id</code> exists in <code>boot_profile.stage0.devices</code>.</li> </ul> <p>Phase gate:</p> <ul> <li>[x] Mixed profile-record streams are deterministic.</li> <li>[x] Invalid first record fails; invalid later record warns and stops head scan.</li> <li>[x] Given same channel + selected device profile id, compatibility output is deterministic.</li> </ul> <p>Deliverable: channel streams can carry mixed DevProfiles/BootProfiles at head and affect session behavior without host mutation.</p>"},{"location":"plans/CHANNELS/#phase-4-artifact-feeling-lucky-pipeline","title":"Phase 4: Artifact \"Feeling Lucky\" Pipeline","text":"<ul> <li>Keep recursive unwrap chain for known wrappers/containers:</li> <li>xz</li> <li>Android sparse</li> <li>zip</li> <li>iso9660</li> <li>gpt/mbr partitions</li> <li>Expose discovered filesystem providers as ordered candidates.</li> <li>Preserve and improve explicit failure reasons (wrong format, missing kernel/modules, unsupported nesting).</li> </ul> <p>Status:</p> <ul> <li>[x] CLI recursive unwrap chain handles xz/android sparse/zip plus partition-backed payloads.</li> <li>[x] Signature-first sniffing (not extension-driven) is used for channel classification.</li> <li>[x] Ordered filesystem providers are discovered for GPT/MBR partition inputs.</li> <li>[x] Failure modes are explicit for unsupported format/nesting paths.</li> <li>[ ] Full unwrap parity across CLI/desktop/web remains in progress.</li> </ul> <p>Deliverable: artifact tails (or naked artifacts) continue to boot with robust sniffing and low extension coupling.</p>"},{"location":"plans/CHANNELS/#phase-5-last-phase-victory-lap-simple-coalescing-filesystem","title":"Phase 5 (Last Phase / Victory Lap): Simple Coalescing Filesystem","text":"<p>Keep this intentionally simple and late.</p> <p>Add a <code>Filesystem</code> implementation that aggregates providers in order:</p> <ul> <li><code>CoalescingFilesystem([FS1, FS2, FS3, ...])</code></li> <li>lookup/open calls:</li> <li>try FS1</li> <li>if not found, try FS2</li> <li>then FS3, etc.</li> <li>return first successful match</li> </ul> <p>This supports mixed-source discovery (for example kernel from one provider and modules from another) without complex union semantics.</p> <p>Notes:</p> <ul> <li>Ordering is policy; keep it deterministic and transparent.</li> <li>No cross-filesystem merge logic beyond first-hit fallback.</li> <li><code>read_dir</code> may remain minimal in v1 of this phase.</li> </ul> <p>Status:</p> <ul> <li>[x] <code>Stage0CoalescingFilesystem</code> is implemented for CLI stage0/boot build paths.</li> <li>[x] lookup/open follows deterministic first-hit fallback order.</li> <li>[x] <code>read_dir</code> remains intentionally minimal (first provider).</li> <li>[ ] Shared coalescing implementation across all runtimes is still pending.</li> </ul> <p>Deliverable: stage0 generator resolves required files across multiple providers with first-hit fallback.</p>"},{"location":"plans/CHANNELS/#phase-6-documentation-pass-user-developer","title":"Phase 6: Documentation Pass (User + Developer)","text":"<p>Goal: cover channel behavior thoroughly for both end users and contributors.</p> <p>Status:</p> <ul> <li>[x] Channel planning/spec baseline exists in <code>docs/plans/CHANNELS.md</code>.</li> <li>[ ] User docs: add a channel-first walkthrough in <code>docs/user/</code> (CLI + desktop + web launch patterns).</li> <li>[ ] User docs: replace remaining rootfs-first examples with channel-first examples.</li> <li>[ ] User docs: document supported channel sources and examples (artifact-only, bootprofile-leading, mixed profile heads).</li> <li>[ ] User docs: add troubleshooting for stream-head warnings/errors and boot-profile selection outcomes.</li> <li>[ ] Developer docs: document stream-head contract (record framing, scan boundaries, fail/warn rules).</li> <li>[ ] Developer docs: document shared-vs-frontend-specific intake behavior and current parity gaps.</li> <li>[ ] Developer docs: document fixture generation/regeneration flow and expected fixture matrix.</li> <li>[ ] Developer docs: document deterministic compatibility/selection rules (<code>stage0.devices</code> behavior).</li> </ul> <p>Deliverable: user + developer docs fully explain channel intake semantics, constraints, and known limitations.</p>"},{"location":"plans/CHANNELS/#derisk-harness","title":"Derisk Harness","text":"<p>We maintain deterministic generated fixtures (not checked in) and classify them in tests.</p> <ul> <li>[x] Fixture generator script: <code>tools/channels/generate-fixtures.sh</code></li> <li>[x] Default output dir (gitignored): <code>build/channels-fixtures</code></li> <li>[x] Core fixture test: <code>crates/fastboop-core/tests/channel_stream_fixture_harness.rs</code></li> </ul> <p>Fixture set should include:</p> <ul> <li>[ ] bootprofile binary header sample</li> <li>[ ] devprofile binary header sample</li> <li>[ ] mixed head streams (<code>bootpro+devpro+artifact</code>, <code>devpro+bootpro+artifact</code>)</li> <li>[ ] invalid-head cases (truncated record first, truncated record after valid record)</li> <li>[x] xz/zip wrappers</li> <li>[x] Android sparse header sample</li> <li>[x] GPT/MBR signature samples</li> <li>[x] ISO9660 descriptor sample</li> <li>[x] EROFS/ext4/FAT filesystem images built via <code>mkfs.*</code></li> </ul>"},{"location":"plans/CHANNELS/#validation-plan","title":"Validation Plan","text":"<p>At minimum during development:</p> <ul> <li>[ ] Tier 0: <code>cargo fmt</code></li> <li>[ ] Tier 0: targeted <code>cargo check</code> for touched crates</li> <li>[ ] Tier 1: <code>dx build -p fastboop-web</code> if <code>packages/web</code> changes</li> <li>[ ] Tier 1: <code>dx build -p fastboop-desktop</code> if <code>packages/desktop</code> changes</li> <li>[ ] Tier 1: relevant crate/package checks for core/cli changes</li> </ul> <p>For substantial implementation phases, run Tier 2 gate from <code>HACKING.md</code> before handoff.</p>"},{"location":"plans/CHANNELS/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>[x] User provides one <code>channel</code> input in CLI session startup flows.</li> <li>[x] Channel streams with leading profile records load accepted records into memory only.</li> <li>[x] Mixed/interleaved DevProfile + BootProfile record heads are supported.</li> <li>[x] If the first record is invalid, fail loudly.</li> <li>[x] If an invalid record appears after at least one valid record, warn and continue with trailing bytes (including block-padding zeros).</li> <li>[x] Naked artifact channels remain valid and are processed as generic artifacts.</li> <li>[x] BootProfile options after device/profile selection include only compatible variants (<code>stage0.devices = {}</code> means all devices).</li> <li>[ ] Existing artifact types still boot through channel intake with full CLI/desktop/web parity.</li> <li>[x] Coalescing filesystem resolves kernel/modules from different providers using deterministic first-hit fallback order (CLI path).</li> <li>[x] No mutating device actions are introduced.</li> </ul>"},{"location":"plans/gibblox-pipelines/","title":"Gibblox Pipeline Adoption Plan","text":""},{"location":"plans/gibblox-pipelines/#goal","title":"Goal","text":"<p>Adopt <code>gibblox-pipeline</code> for BootProfile artifact pipeline schema + binary encoding, remove duplicated BootProfile pipeline definitions/validation from fastboop, and use published <code>gibblox-*</code> crates from crates.io.</p>"},{"location":"plans/gibblox-pipelines/#scope","title":"Scope","text":"<ul> <li>Switch fastboop/smoo workspace consumers from in-tree <code>gibblox/</code> paths to   crates.io <code>gibblox-*</code> dependencies.</li> <li>Refactor BootProfile schema to use <code>gibblox-pipeline</code> types.</li> <li>Refactor BootProfile binary representation to embed   <code>gibblox_pipeline::bin::PipelineSourceBin</code>.</li> <li>Bump BootProfile binary format version and intentionally break old decoding.</li> <li>Remove duplicated BootProfile pipeline validation logic in favor of   <code>gibblox_pipeline::validate_pipeline</code>.</li> <li>Update docs/tests and regenerate committed <code>.bootpro</code> artifacts.</li> </ul>"},{"location":"plans/gibblox-pipelines/#non-goals","title":"Non-Goals","text":"<ul> <li>No migration path or compatibility decode for previous BootProfile binary format.</li> <li>No behavior change to non-mutating boot/install invariants.</li> </ul>"},{"location":"plans/gibblox-pipelines/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Dependency Source Flip</li> <li> <p>Update Cargo manifests in fastboop/smoo workspace members to use      crates.io <code>gibblox-*</code> versions.</p> </li> <li> <p>Schema Refactor (<code>fastboop-schema</code>)</p> </li> <li>Add <code>gibblox-pipeline</code> dependency.</li> <li>Replace BootProfile artifact source type definitions with re-exports from      <code>gibblox_pipeline</code>.</li> <li> <p>Keep existing BootProfile top-level schema (<code>rootfs</code>, <code>kernel</code>, <code>dtbs</code>,      <code>stage0</code>) while delegating pipeline shape to gibblox.</p> </li> <li> <p>Binary Refactor (<code>fastboop-schema::bin</code>)</p> </li> <li>Bump <code>BOOT_PROFILE_BIN_FORMAT_VERSION</code> to <code>2</code>.</li> <li> <p>Replace local <code>BootProfileArtifactSourceBin</code> with      <code>gibblox_pipeline::bin::PipelineSourceBin</code> in BootProfile bin structs.</p> </li> <li> <p>Core Validation Refactor (<code>fastboop-core</code>)</p> </li> <li>Delegate pipeline validation to <code>gibblox_pipeline::validate_pipeline</code>.</li> <li> <p>Keep fastboop-specific checks only:</p> <ul> <li>rootfs filesystem must support stage0 switchroot (<code>erofs</code>/<code>ext4</code>)</li> <li>non-empty <code>kernel.path</code> / <code>dtbs.path</code>.</li> </ul> </li> <li> <p>Docs + Fixtures</p> </li> <li>Update BootProfile docs and channel plan format-version notes.</li> <li> <p>Regenerate tracked <code>.bootpro</code> artifacts with the new v2 format.</p> </li> <li> <p>Validation</p> </li> <li><code>cargo fmt</code></li> <li>targeted <code>cargo check</code>/<code>cargo test</code> for touched crates</li> <li><code>dx build -p fastboop-desktop</code></li> <li><code>dx build -p fastboop-web</code></li> </ol>"},{"location":"plans/gibblox-pipelines/#expected-outcome","title":"Expected Outcome","text":"<ul> <li>BootProfile pipeline schema + bin encoding are sourced from gibblox.</li> <li>BootProfile binary format is v2-only (no v1 compatibility path).</li> <li>Duplicated pipeline parsing/validation code in fastboop is significantly reduced.</li> </ul>"},{"location":"plans/releasemachinery/","title":"Release Machinery Plan (first pass)","text":""},{"location":"plans/releasemachinery/#goal","title":"Goal","text":"<p>Stand up a reliable <code>0.0.1-rc.N</code> -&gt; <code>0.0.1</code> release pipeline for fastboop that:</p> <ul> <li>publishes GitHub Releases with downstream-consumable artifacts (<code>.deb</code>, <code>.apk</code>, binary tarballs),</li> <li>supports rehearsal via <code>release/v*</code> PRs before tagging,</li> <li>keeps crates.io publishing sane while <code>smoo</code> and <code>gibblox</code> are being peeled back to canonical repos.</li> </ul> <p>This first pass is intentionally pragmatic: artifact release orchestration now, full crates.io automation after subtree split work lands.</p>"},{"location":"plans/releasemachinery/#current-state-baseline","title":"Current State (baseline)","text":"<ul> <li><code>.github/workflows/release.yml</code> is tag-only and only creates a release shell.</li> <li><code>.github/workflows/ci.yml</code> builds/tests and can upload release binaries only on <code>release: published</code> events.</li> <li><code>.github/workflows/debian.yml</code> builds <code>.deb</code> artifacts for CI contexts.</li> <li><code>.github/workflows/alpine.yml</code> builds <code>.apk</code> artifacts and uploads on <code>release: published</code>.</li> <li><code>just bump</code> exists, but it is not yet semver-rc aware for distro-specific version formats.</li> </ul>"},{"location":"plans/releasemachinery/#first-pass-decisions","title":"First-Pass Decisions","text":"<ul> <li>Keep a single orchestrator in fastboop (<code>.github/workflows/release.yml</code>) that decides release mode and coordinates artifact jobs.</li> <li>Use two modes:</li> <li><code>tag</code> mode: triggered by <code>v*</code> tags, creates/publishes the real GitHub Release.</li> <li><code>pr</code> mode: triggered by <code>release/v*</code> PRs from same repo, builds and verifies release payload without publishing.</li> <li>Treat <code>-rc.N</code> as prerelease everywhere release metadata needs it.</li> <li>Defer cross-workspace crates.io publishing (<code>fastboop</code> + vendored <code>smoo</code> + vendored <code>gibblox</code>) until canonical repo prereleases exist and dependency edges are clean.</li> </ul>"},{"location":"plans/releasemachinery/#release-contract","title":"Release Contract","text":""},{"location":"plans/releasemachinery/#version-and-ref-forms","title":"Version and ref forms","text":"<ul> <li>Release branch: <code>release/vX.Y.Z</code> or <code>release/vX.Y.Z-rc.N</code></li> <li>Release tag: <code>vX.Y.Z</code> or <code>vX.Y.Z-rc.N</code></li> <li>Prerelease detection: semver suffix <code>-rc.N</code></li> </ul>"},{"location":"plans/releasemachinery/#mode-gate","title":"Mode gate","text":"<p>Release orchestration is enabled only when:</p> <ul> <li>event is <code>push</code> and ref is a matching <code>v*</code> tag, or</li> <li>event is <code>pull_request</code> and head ref matches <code>release/vX.Y.Z(-rc.N)?</code> from the same repository.</li> </ul>"},{"location":"plans/releasemachinery/#artifact-set-first-pass","title":"Artifact set (first pass)","text":"<ul> <li>static CLI binaries bundled as tarballs (at least <code>x86_64-unknown-linux-musl</code>, <code>aarch64-unknown-linux-musl</code>)</li> <li>Debian packages: <code>debs/*.deb</code></li> <li>Alpine packages: <code>packages/*.apk</code></li> <li>packaging metadata: <code>APKBUILD</code></li> <li>checksum manifest for uploaded artifacts (<code>SHA256SUMS</code>)</li> </ul> <p>PR mode verifies this full set exists. Tag mode uploads the same set to the GitHub Release.</p>"},{"location":"plans/releasemachinery/#scope-first-pass","title":"Scope (first pass)","text":"<ol> <li>Release orchestrator upgrade</li> <li>Replace current minimal <code>.github/workflows/release.yml</code> with phrog-style gate + fan-out + fan-in structure.</li> <li> <p>Include <code>pass</code> job and publish-only-on-success behavior.</p> </li> <li> <p>Artifact fan-out wiring</p> </li> <li>Reuse existing build logic from current CI/debian/alpine workflows where practical.</li> <li> <p>If reuse needs <code>workflow_call</code>, refactor those workflows minimally to support both standalone CI and orchestration.</p> </li> <li> <p>PR rehearsal behavior</p> </li> <li> <p><code>release/v*</code> PRs run the release pipeline in dry-run style:</p> <ul> <li>no GitHub Release publication,</li> <li>no crates.io publication,</li> <li>artifact completeness verification only.</li> </ul> </li> <li> <p>Tag publish behavior</p> </li> <li><code>v*</code> tags create draft release (prerelease flag derived from version),</li> <li>upload artifacts,</li> <li> <p>publish draft only after all required jobs are green.</p> </li> <li> <p>Version bump helper hardening</p> </li> <li>Upgrade <code>just bump</code> semantics to map semver prerelease forms correctly:<ul> <li>Cargo: <code>0.0.1-rc.1</code></li> <li>RPM/APK version fields: <code>0.0.1_rc1</code> where required by packaging constraints</li> <li>Debian changelog version: <code>0.0.1~rc1</code></li> </ul> </li> </ol>"},{"location":"plans/releasemachinery/#out-of-scope-first-pass","title":"Out of Scope (first pass)","text":"<ul> <li>Enabling crates.io publish for all vendored subtree crates from fastboop.</li> <li>Full <code>release-plz</code> ownership in this repository.</li> <li>Auto-generated release PRs/issues as the source of truth for versioning.</li> <li>Any compatibility shims/migration aliases (project remains unreleased policy).</li> </ul>"},{"location":"plans/releasemachinery/#release-plz-release-please-positioning","title":"release-plz / release-please Positioning","text":"<p>For this repo shape, use them as helpers, not the conductor:</p> <ul> <li>Now (first pass): orchestrated GitHub release + packaging assets in fastboop; crates publishing deferred.</li> <li>During subtree peel-out: publish <code>smoo</code> and <code>gibblox</code> prereleases from canonical repos.</li> <li>After peel-out stabilizes: introduce <code>release-plz</code> where dependency graph and publish order are clean.</li> </ul> <p>Rationale: fastboop currently has many path-linked edges into vendored workspaces; reliable crates.io automation needs canonical published versions first.</p>"},{"location":"plans/releasemachinery/#implementation-sketch","title":"Implementation Sketch","text":"<p>Target job graph in <code>.github/workflows/release.yml</code>:</p> <ol> <li><code>gate</code> -&gt; decide <code>enabled</code>, <code>mode</code>, <code>prerelease</code></li> <li><code>release</code> -&gt; create draft (tag mode) or skip creation (PR mode)</li> <li><code>build-binaries</code>, <code>debian</code>, <code>alpine</code> -&gt; produce artifacts</li> <li><code>publish-assets</code> -&gt; upload to release in tag mode; verify payload in PR mode</li> <li><code>pass</code> -&gt; aggregate required checks</li> <li><code>publish-release</code> -&gt; undraft release after successful <code>pass</code> (tag mode only)</li> </ol>"},{"location":"plans/releasemachinery/#secrets-and-access","title":"Secrets and Access","text":"<ul> <li><code>RELEASE_GITHUB_TOKEN</code> for release/tag operations that need elevated permissions.</li> <li><code>GITHUB_TOKEN</code> for normal artifact and PR operations.</li> <li><code>CARGO_REGISTRY_TOKEN</code> is intentionally not required in first pass (no crates publish yet).</li> </ul>"},{"location":"plans/releasemachinery/#validation-plan","title":"Validation Plan","text":"<p>For release-machinery edits:</p> <ul> <li>Tier 0:</li> <li><code>cargo fmt</code></li> <li>targeted checks only if Rust code changes</li> <li>Workflow verification:</li> <li>syntax sanity via CI run on a throwaway <code>release/v0.0.1-rc.1</code> PR branch</li> <li>confirm PR mode verifies complete artifact set</li> <li>confirm tag mode creates draft, uploads assets, then publishes after pass</li> </ul> <p>If workflow behavior cannot be fully verified in-session (no remote actions execution), report explicitly and leave an operator checklist.</p>"},{"location":"plans/releasemachinery/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>A <code>release/v0.0.1-rc.1</code> PR exercises full release artifact flow without publishing a release.</li> <li>A <code>v0.0.1-rc.1</code> tag produces a GitHub prerelease with all expected assets.</li> <li>A <code>v0.0.1</code> tag produces a non-prerelease GitHub release with the same artifact families.</li> <li>Pipeline fails loudly when any artifact family is missing.</li> <li>No crates.io publish side effects occur from fastboop first-pass machinery.</li> </ul>"},{"location":"plans/releasemachinery/#follow-up-after-canonical-repo-rcs","title":"Follow-up After Canonical Repo RCs","text":"<p>Once <code>smoo</code> and <code>gibblox</code> canonical prereleases are in place and fastboop consumes registry versions where needed:</p> <ul> <li>add publish dry-runs in PR mode,</li> <li>add real crates.io publish in tag mode,</li> <li>decide whether <code>release-plz</code> becomes authoritative for version/changelog/publish automation.</li> </ul>"},{"location":"plans/u-boot-trampoline/","title":"U-Boot Trampoline Plan (v0)","text":""},{"location":"plans/u-boot-trampoline/#goal","title":"Goal","text":"<p>Add a first-class U-Boot trampoline boot path for devices (like <code>google-sargo</code>) where direct Linux Android boot images are rejected by ABL, while preserving the existing direct-kernel path for devices that already work.</p> <p>The trampoline artifact must be sourced through the existing gibblox artifact pipeline (HTTP, casync, file, and nested wrappers/selectors), not built locally by fastboop.</p>"},{"location":"plans/u-boot-trampoline/#why-this-exists","title":"Why This Exists","text":"<ul> <li>On sargo, fastboop can successfully <code>download</code> but <code>boot</code> fails with:</li> <li><code>Error verifying the received boot.img: Volume Corrupt</code></li> <li>This failure reproduces with and without <code>arm64_text_offset</code> kernel shim.</li> <li>A known-good manual path is:</li> <li>booting gzipped <code>u-boot-nodtb.bin</code> with appended sargo DTB via fastboot,</li> <li>then letting U-Boot continue boot flow.</li> </ul> <p>Conclusion: we need an explicit trampoline mode, not only Linux <code>Image</code> header patching.</p>"},{"location":"plans/u-boot-trampoline/#non-goals","title":"Non-Goals","text":"<ul> <li>No flashing, formatting, slot switching, or any other mutating behavior.</li> <li>No in-tree U-Boot build orchestration in fastboop.</li> <li>No deprecation/compat shims (project is unreleased).</li> </ul>"},{"location":"plans/u-boot-trampoline/#proposed-data-model","title":"Proposed Data Model","text":""},{"location":"plans/u-boot-trampoline/#device-profile-devpro","title":"Device Profile (DevPro)","text":"<p>Add an explicit launch mode for Android boot image assembly:</p> <ul> <li><code>direct</code> (default): current behavior.</li> <li><code>u_boot_fit</code> (new): stage1 kernel is U-Boot trampoline; stage2 Linux payload is carried in FIT.</li> </ul> <p>Proposed shape (illustrative):</p> <pre><code>boot:\n  fastboot_boot:\n    android_bootimg:\n      header_version: 0\n      page_size: 4096\n      kernel_offset: 0x00008000\n\n      launch:\n        u_boot_fit:\n          fit_config: fastboop\n</code></pre> <p>Notes:</p> <ul> <li><code>fit_config</code> defaults to <code>fastboop</code>.</li> <li>Existing <code>kernel.shims</code> remains valid and applies to the stage2 Linux kernel payload.</li> </ul>"},{"location":"plans/u-boot-trampoline/#boot-profile","title":"Boot Profile","text":"<p>Add optional trampoline artifact source:</p> <ul> <li><code>trampoline</code>: <code>BootProfileArtifactSource</code></li> </ul> <p>This is intentionally a raw artifact source (no path), so it can be fetched from arbitrary gibblox pipelines and wrappers.</p> <p>Proposed shape (illustrative):</p> <pre><code>id: sargo-mainline\nrootfs:\n  ostree:\n    erofs:\n      casync:\n        index: https://example.invalid/rootfs.caibx\n\ntrampoline:\n  xz:\n    http: https://example.invalid/u-boot-sargo-nodtb.bin.gz.xz\n</code></pre>"},{"location":"plans/u-boot-trampoline/#runtime-contract","title":"Runtime Contract","text":"<p><code>u_boot_fit</code> mode assumes the trampoline U-Boot artifact is configured to boot a FIT from ramdisk memory, using the configured FIT config name.</p> <p>Expected default contract:</p> <ul> <li>U-Boot executes equivalent of: <code>bootm ${ramdisk_addr_r}#fastboop</code></li> </ul> <p>If a trampoline image does not satisfy that contract, fastboop will still boot stage1, but handoff will fail inside U-Boot.</p>"},{"location":"plans/u-boot-trampoline/#end-to-end-flow-u_boot_fit","title":"End-to-End Flow (u_boot_fit)","text":"<ol> <li>Resolve channel + boot profile as today.</li> <li>Resolve stage2 Linux kernel/dtb/initrd as today (including kernel shims and DT overlays).</li> <li>Build FIT payload in-memory containing:</li> <li>kernel (stage2 Linux kernel bytes),</li> <li>ramdisk (stage0 initrd),</li> <li>fdt (selected DTB after overlays/injection),</li> <li>one default config (<code>fit_config</code>, default <code>fastboop</code>).</li> <li>Resolve <code>boot_profile.trampoline</code> via gibblox artifact resolver.</li> <li>Assemble stage1 Android boot image:</li> <li>kernel = trampoline artifact bytes (plus DTB append if DevPro encoding requests it),</li> <li>ramdisk = FIT payload,</li> <li>cmdline = existing cmdline assembly logic.</li> <li>Send with existing fastboot download + boot transport.</li> </ol>"},{"location":"plans/u-boot-trampoline/#implementation-workstreams","title":"Implementation Workstreams","text":""},{"location":"plans/u-boot-trampoline/#1-schema-codec","title":"1) Schema + Codec","text":"<ul> <li><code>crates/fastboop-schema/src/lib.rs</code></li> <li>add DevPro launch mode for Android bootimg,</li> <li>add <code>BootProfile{Manifest}.trampoline</code>.</li> <li><code>crates/fastboop-schema/src/bin.rs</code></li> <li>include trampoline field in binary profile codec structs.</li> <li><code>crates/fastboop-core/src/bootprofile.rs</code></li> <li>validate trampoline artifact pipeline with existing depth/selector constraints.</li> </ul>"},{"location":"plans/u-boot-trampoline/#2-artifact-resolution-plumbing","title":"2) Artifact Resolution Plumbing","text":"<ul> <li><code>cli/src/commands/mod.rs</code></li> <li>extend <code>BootProfileSourceOverrides</code> to carry trampoline bytes,</li> <li>resolve <code>boot_profile.trampoline</code> via <code>open_artifact_source()</code>.</li> </ul>"},{"location":"plans/u-boot-trampoline/#3-fit-builder","title":"3) FIT Builder","text":"<ul> <li><code>crates/fastboop-stage0-generator</code></li> <li>add a small deterministic FIT builder module for one kernel/ramdisk/fdt config,</li> <li>avoid external <code>mkimage</code> dependency.</li> </ul>"},{"location":"plans/u-boot-trampoline/#4-boot-assembly-path","title":"4) Boot Assembly Path","text":"<ul> <li><code>cli/src/commands/boot.rs</code></li> <li>branch on DevPro launch mode:<ul> <li><code>direct</code>: unchanged,</li> <li><code>u_boot_fit</code>: use trampoline + FIT flow.</li> </ul> </li> <li>keep direct path behavior and defaults stable.</li> </ul>"},{"location":"plans/u-boot-trampoline/#5-stage0-command-behavior","title":"5) Stage0 Command Behavior","text":"<ul> <li><code>cli/src/commands/stage0.rs</code></li> <li>when <code>u_boot_fit</code> mode is selected, continue producing stage2 artifacts,     but do not confuse trampoline artifact with stage2 kernel override.</li> </ul>"},{"location":"plans/u-boot-trampoline/#6-sargo-devpro-update","title":"6) Sargo DevPro Update","text":"<ul> <li><code>devprofiles.d/google-sargo.yaml</code></li> <li>switch launch mode to <code>u_boot_fit</code>.</li> <li>keep <code>arm64_text_offset</code> shim for stage2 kernel initially.</li> </ul>"},{"location":"plans/u-boot-trampoline/#7-docs","title":"7) Docs","text":"<ul> <li><code>docs/dev/DEVICE_PROFILES.md</code></li> <li>describe launch modes (<code>direct</code>, <code>u_boot_fit</code>) and stage2 shim semantics.</li> <li><code>docs/dev/BOOT_PROFILES.md</code></li> <li>document <code>trampoline</code> artifact sourcing via gibblox.</li> </ul>"},{"location":"plans/u-boot-trampoline/#validation-plan","title":"Validation Plan","text":"<p>During development:</p> <ul> <li><code>cargo fmt</code></li> <li><code>cargo check -p fastboop-schema -p fastboop-core -p fastboop-stage0-generator -p fastboop-cli</code></li> <li><code>cargo test -p fastboop-core bootprofile</code></li> <li><code>cargo test -p fastboop-stage0-generator</code></li> </ul> <p>Device smoke gate (sargo):</p> <ul> <li><code>fastboop-cli boot --device-profile google-sargo &lt;channel&gt;</code> with trampoline-enabled boot profile.</li> <li>verify fastboot no longer fails with <code>Volume Corrupt</code> at stage1 boot verification.</li> </ul>"},{"location":"plans/u-boot-trampoline/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ul> <li>Trampoline env/bootcmd mismatch:</li> <li>mitigate by documenting strict runtime contract and surfacing explicit errors/logging.</li> <li>FIT compatibility variance across U-Boot builds:</li> <li>start with minimal FIT layout matching U-Boot docs/examples; add hashes only if required.</li> <li>Schema complexity creep:</li> <li>keep launch mode narrow (<code>u_boot_fit</code> only) for v0.</li> </ul>"},{"location":"plans/u-boot-trampoline/#follow-ups-post-v0","title":"Follow-Ups (Post-v0)","text":"<ul> <li>Desktop/web boot path parity for trampoline mode.</li> <li>Optional trampoline compatibility probe or manifest metadata.</li> <li>Optional alternate handoff mechanisms if specific boards need non-<code>bootm</code> contracts.</li> </ul>"},{"location":"user/","title":"fastboop user docs","text":"<p>fastboop boots supported phones and pocket computers into Linux over USB without flashing storage.</p>"},{"location":"user/#what-this-gives-you","title":"What this gives you","text":"<ul> <li>Non-mutating boots from vendor USB boot mode.</li> <li>Reuse of upstream distro/rootfs artifacts.</li> <li>Ephemeral live sessions for trying a distro and validating hardware paths.</li> </ul>"},{"location":"user/#next-steps","title":"Next steps","text":"<ul> <li>Start with Quick start.</li> <li>Read Device permissions before connecting hardware.</li> <li>Check FAQ for common gotchas.</li> </ul>"},{"location":"user/device-permissions/","title":"Device permissions","text":"<p>Stable link: <code>https://fastboop.win/device-permissions</code>.</p> <p>fastboop requires access to vendor USB boot mode interfaces so it can detect and boot a supported device.</p>"},{"location":"user/device-permissions/#safety-and-scope","title":"Safety and scope","text":"<ul> <li>fastboop boot flow is non-mutating.</li> <li>No flash / erase / format / slot-toggle actions are part of the supported path.</li> <li>Boot is ephemeral and intended for live sessions.</li> </ul>"},{"location":"user/device-permissions/#host-permission-model-starter","title":"Host permission model (starter)","text":"<p>This page is a placeholder for a stable user-facing permission guide that will include:</p> <ul> <li>Linux <code>udev</code> rule setup.</li> <li>Group/ACL requirements for USB device access.</li> <li>Browser permission behavior for WebUSB frontends.</li> </ul> <p>Until this page is expanded, use CLI/desktop paths where your user has explicit USB access rights.</p>"},{"location":"user/faq/","title":"FAQ","text":""},{"location":"user/faq/#does-fastboop-flash-my-device","title":"Does fastboop flash my device?","text":"<p>No. fastboop's supported flow is non-mutating and boots ephemerally.</p>"},{"location":"user/faq/#is-this-an-installer","title":"Is this an installer?","text":"<p>No. fastboop is a live-boot pipeline, not an installer and not a policy manager.</p>"},{"location":"user/faq/#which-devices-are-supported","title":"Which devices are supported?","text":"<p>Support is profile-driven. See <code>devprofiles.d/</code> and the developer docs for profile semantics.</p>"},{"location":"user/quick-start/","title":"Quick start","text":"<p>This is a starter quick-start. It will be expanded with distro- and device-specific examples.</p>"},{"location":"user/quick-start/#1-build-fastboop","title":"1) Build fastboop","text":"<pre><code>cargo build --workspace --locked\n</code></pre>"},{"location":"user/quick-start/#2-confirm-your-device-can-be-matched","title":"2) Confirm your device can be matched","text":"<pre><code>cargo run -p fastboop-cli -- detect\n</code></pre>"},{"location":"user/quick-start/#3-generate-stage0-from-your-selected-rootfs-artifact","title":"3) Generate stage0 from your selected rootfs artifact","text":"<pre><code>cargo run -p fastboop-cli -- stage0 --help\n</code></pre>"},{"location":"user/quick-start/#3b-inspect-and-compile-device-profiles","title":"3b) Inspect and compile device profiles","text":"<pre><code>cargo run -p fastboop-cli -- devprofile --help\n</code></pre>"},{"location":"user/quick-start/#4-boot-ephemerally","title":"4) Boot ephemerally","text":"<pre><code>cargo run -p fastboop-cli -- boot --help\n</code></pre> <p>No flashing or partition mutation is performed in the supported flow.</p>"}]}